<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Kernel-Foundation-Enumerable-Enumeration'>/**
</span> * @class Kernel.Foundation.Enumerable.Enumeration
 * Creates several symbolic constants
 *
 * ### Example:
 *
 *     Suit = new Enumeration(&quot;spades&quot;, &quot;hearts&quot;, &quot;diamonds&quot;, &quot;clovers&quot;)
 *     // { spades: 0, hearts: 1, diamonds: 2, clovers: 3}
 *
 *     Suit.hearts == 1
 *     // =&gt; true
 *
 *     var a = new Enumeration(&quot;spades&quot;, &quot;hearts&quot;, [ &quot;red&quot;, &quot;black&quot;], &quot;diamonds&quot;, &quot;clovers&quot;)
 *     Object.keys(a.hearts)
 *     // =&gt; red,black
 *
 *     a.hearts
 *     // =&gt; 1
 *
 *     a.hearts.red
 *     // =&gt; 1
 *
 * Attributes, as a.hearts, are holding
 * {@link Kernel.Foundation.DataType.VersionNumber VersionNumber} objects.
 *
 * ### Inner Structure
 *
 *     {
 *       &quot;spades&quot;: 0,
 *       &quot;hearts&quot;: { 1,
 *       	           &quot;red&quot;: 1,
 *       	           &quot;black&quot;: 2
 *                  },
 *        &quot;diamonds&quot;: 2,
 *        &quot;clovers&quot;: 3
 *     }
 *
 * ### Sugar
 *
 *  Despite,
 *
 *     a.hearts.black == 2
 *     //=&gt; true
 *
 * when stringifying,
 *
 *     a.hearts.black.toString()
 *     //=&gt; &quot;1.2&quot;
 *
 * due to {@link Kernel.Foundation.DataType.VersionNumber VersionNumber} properties.
 */

<span id='Kernel-Foundation-Enumerable-Enumeration-method-constructor'>/**
</span> * @method constructor
 * Create a list of constant given an
 * {@link Kernel.Foundation.Enumerable.InterleavedArray InterleavedArray}
 *
 * ### Example
 *
 *     var a = new Enumeration(&quot;spades&quot;, &quot;hearts&quot;, [ &quot;red&quot;, &quot;black&quot;], &quot;diamonds&quot;, &quot;clovers&quot;)
 *
 * @param {String...} constants List of constants to be used as an InterleavedArray.
 */
function Enumeration(constants) {
    var args = arguments // Copy of arguments
    if (constants instanceof Enumeration)
        args = constants.ia // Copy constructor trick.
    Object.defineProperty(this, &quot;ia&quot;, {
        value: new(ApplyProxyConstructor(InterleavedArray, args)),
        enumerable: false,
        writable: true
    })

    Enumeration.prototype.transpose.call(this)
}

<span id='Kernel-Foundation-Enumerable-Enumeration-method-transpose'>/**
</span> * @method transpose
 * Takes an InterleavedArray and inverts it, due to InterleavedArray and Enumeration reciprocity.
 * Not enumerable, not configurable, not writable.
 *
 * Given the following InterleavedArray,
 *
 *        {
 *        &quot;0&quot;: &quot;spades&quot;,
 *        &quot;1&quot;: &quot;hearts&quot;,
 *        &quot;1.1&quot;: &quot;red&quot;,
 *        &quot;1.2&quot;: &quot;black&quot;,
 *        &quot;2&quot;: &quot;diamonds&quot;,
 *        &quot;3&quot;: &quot;clovers&quot;
 *       }
 *
 * will be turned inside this into:
 *         {
 *       &quot;spades&quot;: 0,
 *       &quot;hearts&quot;: { 1,
 *                   &quot;red&quot;: 1.1,
 *                   &quot;black&quot;: 1.2
 *                  },
 *        &quot;diamonds&quot;: 2,
 *        &quot;clovers&quot;: 3
 *        }
 *
 *  through this method.
 *
 * @param  {Class} [Type=VersionNumber] Class for assigning values
 */
Enumeration.prototype.transpose = function(Type) {
    Type = Type || this.Type || VersionNumber

    var keys = this.ia.keys()
    for (var k = 0; k &lt; keys.length; k++) {
        var ia_value = this.ia[keys[k]]
        var deep = this
        var key_chain = keys[k].split(&quot;.&quot;)

        for (var i = 0; i &lt; key_chain.length - 1; i++) {
            var parent = this.ia[key_chain.slice(0, i + 1).join(&quot;.&quot;)]

            if (parent in deep)
                deep = deep[parent]
        }
        deep[ia_value] = deep[ia_value] || new Type(keys[k])
        Object.defineProperty(deep[ia_value], &quot;name&quot;, {
            value: ia_value,
            writable: true
        })
    }
}

<span id='Kernel-Foundation-Enumerable-Enumeration-method-full_name'>/**
</span> * @method full_name
 * Returns the full name of a constant.
 *
 * ###Example
 *
 *     var a = new Enumeration(&quot;red&quot;, [&quot;hearts&quot;, &quot;diamonds&quot;])
 *     a.full_name(&quot;0.2&quot;)
 *     //=&gt; &quot;red.diamonds&quot;
 *
 * @param  {String} key key to search
 * @return {String}     Name of the value sarched.
 */
Enumeration.prototype.full_name = function(key){
    var name = &quot;&quot;

    var indices = key.split(&#39;.&#39;)
    for (var i=0; i&lt;indices.length; i++)
        name += this.ia[indices.slice(0, i+1).join(&#39;.&#39;)] + &quot;.&quot;

    return name.substr(0, name.length-1)
}

<span id='Kernel-Foundation-Enumerable-Enumeration-method-each'>/**
</span> * @method  each
 * Iterates over key-value pairs inside the enumeration.
 *
 * ### Example
 *
 *   Let a be defined as
 *
 *     var a = new Enumeration(&quot;spades&quot;, &quot;hearts&quot;, [ &quot;red&quot;, &quot;black&quot;], &quot;diamonds&quot;, &quot;clovers&quot;)
 *
 *  with the following inner structure:
 *
 *        {
 *       &quot;spades&quot;: 0,
 *       &quot;hearts&quot;: { 1,
 *                   &quot;red&quot;: 1,
 *                   &quot;black&quot;: 2
 *                  },
 *        &quot;diamonds&quot;: 2,
 *        &quot;clovers&quot;: 3
 *        }
 *
 *   When called
 *
 *     a.each(function(key, value) {;})
 *
 * key-value pairs will be:
 *
 * | key          | value  |
 * |--------------|-------:|
 * | spades       | 0      |
 * | hearts       | 1      |
 * | hearts.red   | 1.1    |
 * | hearts.black | 1.2    |
 * | diamonds     | 2      |
 * | clovers      | 3      |
 *
 */
Enumeration.prototype.each = function() {
    var that = this
    this.ia.keys().each(function(string_key) {
        // string_key is string 1.2.3 for instance
        // Get the VersionNumber 1.2.3 for the value.
        var key = string_key.split(&quot;.&quot;)
        var value = that
        for (var i = 0; i &lt; key.length;
            value = value[that.ia[key.slice(0, i + 1).join(&#39;.&#39;)]],
            i++);
        Enumeration.prototype.each.yield(that.full_name(string_key), value)
    })
}

<span id='Kernel-Foundation-Enumerable-Enumeration-method-get'>/**
</span> * @method get
 * Returns a the value of a constant given the constant name.
 * When the value is passed it is returned previously checking
 * is actually present in the set.
 * null is returned when key isn&#39;t found.
 *
 *
 * ### Example
 *
 * Given:
 *
 *      var a = new Enumeration(&quot;spades&quot;, &quot;hearts&quot;, [ &quot;red&quot;, &quot;black&quot;], &quot;diamonds&quot;, &quot;clovers&quot;)
 *
 * will result in
 *
 *        {
 *       &quot;spades&quot;: 0,
 *       &quot;hearts&quot;: { 1,
 *                   &quot;red&quot;: 1,
 *                   &quot;black&quot;: 2
 *                  },
 *        &quot;diamonds&quot;: 2,
 *        &quot;clovers&quot;: 3
 *        }
 *
 * executing
 *
 *      a.get(&quot;hearts.red&quot;)
 *      // =&gt; &#39;1.1&#39;
 *      a.get(&quot;1.1&quot;)
 *      // =&gt; &#39;1.1&#39;
 *      a.get(&#39;5.7&#39;)
 *      // =&gt; null
 *      a.get(&quot;bat.man&quot;)
 *      // =&gt; null
 *
 * ## Notice
 *
 *  Despite the return value appears as a string in the example above,
 *  actually is a VersionNumber (or derivated). This seems interesting
 *  since this kind of numbers can hold the ability to perform actions,
 *  as we can see in the {@link Engine.State State} class.
 *
 * @param  {String} label Constant name to look for.
 * @return {VersionNumber}       Value of the constant.
 */
Enumeration.prototype.get = function(label) {
    label = new String(label)
    if ( /\d+(?:\.\d+)*/.test(label) )
        if (this.ia.keys().include$U(label))
            return this.get(this.full_name(label))
        else
            return null

    var position = null
    this.each(function (key, value) {
        if (key == label)
            position = value
    })
    return position
}

<span id='Kernel-Foundation-Enumerable-Enumeration-method-getS-B'>/**
</span> * @method get$B
 * Same as #get but creating empty states when missing intermediate ones.
 * Take option -p in mkdir as an example
 *
 * Given state running
 *    running
 * when getting$B running.fast.by_bike
 *     running.fast
 * and
 *     running.fast.by_bike
 * will be created.
 *
 * @param  {[type]} label [description]
 * @return {[type]}       [description]
 */
Enumeration.prototype.get$B = function(label) {
        var position = null
        label = label.split(&quot;.&quot;)
        var reached = []
        while(label.length){
            var new_key = label.shift()
            reached.push(new_key)
            if ( !(position = this.get(reached.join(&quot;.&quot;)))){
                reached.pop()
                var host = this.get(reached.join(&quot;.&quot;))
                this.ia.infiltrate(new_key, host)
                this.transpose()
                label.unshift(new_key)
            }
        }

    return position
}

<span id='Kernel-Foundation-Enumerable-Enumeration-method-add'>/**
</span> * @method add
 * Enlarges the enumeration set by adding new constants at a given position.
 *
 * ### Example
 *
 * Given:
 *
 *      var a = new Enumeration(&quot;spades&quot;, &quot;hearts&quot;, [ &quot;red&quot;, &quot;black&quot;], &quot;diamonds&quot;, &quot;clovers&quot;)
 *
 * will result in
 *
 *        {
 *       &quot;spades&quot;: 0,
 *       &quot;hearts&quot;: { 1,
 *                   &quot;red&quot;: 1,
 *                   &quot;black&quot;: 2
 *                  },
 *        &quot;diamonds&quot;: 2,
 *        &quot;clovers&quot;: 3
 *        }
 *
 * and,
 *      a.add([&quot;white&quot;, &quot;yellow&quot;], &quot;hearts.red&quot;)
 * or,
 *      a.add([&quot;white&quot;, &quot;yellow&quot;], &quot;1.1&quot;)
 *
 * will end up in,
 *
 *     {
 *       &quot;spades&quot;: 0,
 *       &quot;hearts&quot;: { 1,
 *                   &quot;red&quot;: { 1,
 *                            &quot;white&quot;: 1,
 *                            &quot;yellow&quot;: 2
 *                          },
 *                   &quot;black&quot;: 2
 *                  },
 *        &quot;diamonds&quot;: 2,
 *        &quot;clovers&quot;: 3
 *        }
 *
 * @param {Array | String} constants List of new constant values.
 * @param {String} [place]    Name or value of the position to insert the constants.
 *                         in cannot be empty when the last high level position
 *                         , clovers in the example above, is undefined.
 * @return {VersionNumber}    Returns the place where the constants were added.
 */
Enumeration.prototype.add = function(constants, place){
    if (!constants || constants == &quot;&quot;)
        return this
    if (place)
        place = this.get(place)
    this.ia.infiltrate(constants, place)
    Enumeration.prototype.transpose.call(this)
    return place || this
}

<span id='Kernel-Foundation-Enumerable-Enumeration-method-addS-B'>/**
</span> * @method  add$B
 * Same as #add, but creating intermediate states when needed. See #get$B for
 * further reference.
 *
 * @param  {[type]} constants [description]
 * @param  {[type]} place     [description]
 * @return {[type]}           [description]
 */
Enumeration.prototype.add$B = function(constants, place){
    if (!constants || constants == &quot;&quot;)
        return this
    if (place)
        place = this.get$B(place)
    this.ia.infiltrate(constants, place)
    Enumeration.prototype.transpose.call(this)
    return place || this
}

Enumeration.prototype.stop_enumerating([&quot;transpose&quot;, &quot;each&quot;, &quot;full_name&quot;, &quot;get&quot;, &quot;add&quot;, &quot;get$B&quot;, &quot;add$B&quot;])



//todo: Needed include$U. Depends on making module Enumerable and mixing.</pre>
</body>
</html>
