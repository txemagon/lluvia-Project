<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Kernel-Foundation-Architecture-Class'>/**
</span> * @class Kernel.Foundation.Architecture.Class
 * @extends Kernel.Foundation.Architecture.Module
 * Base class of all lluvia classes.
 *
 * ### Example
 *
 * The greet method would be called after _introduce_ and _prepare_
 *
 *     this.before_filters = { greet: [ function introduce(){ alert(&quot;introduce&quot;) },
 *                                      function prepare()  { alert(&quot;prepare&quot;)   } ]
 *
 * Do not handle theses properties directly. Use add _ before _ filter and add _ after _ filter instead.
 *
 */
Class.prototype = new Module
Class.prototype.constructor = Class

function Class(){
   var self = this instanceof Function ? this : eval(this.constructor.name)
   var that = this
   this.before_filters = {}
   this.after_filters  = {}
   this.attr_readers = []
   this.attr_writers = []
}


<span id='Kernel-Foundation-Architecture-Class-property-before_filters'>/**
</span> * @property {Object} before_filters Hash with all the functions to be called before a particular method.
 */
<span id='Kernel-Foundation-Architecture-Class-property-after_filters'>/**
</span> * @property {Object} after_filters  Hash with all the functions to be called after a particular method.
 */
<span id='Kernel-Foundation-Architecture-Class-property-attr_readers'>/**
</span> * @property {Array} attr_readers list of getters.
 */
<span id='Kernel-Foundation-Architecture-Class-property-attr_writers'>/**
</span> * @property {Array} attr_writers list of setters.
 */

<span id='Kernel-Foundation-Architecture-Class-property-all'>/**
</span> * List of all created classes.
 */
Class.all = []


<span id='Kernel-Foundation-Architecture-Class-method-create_attr'>/**
</span> * @method create_attr
 * Creates an attribute.
 *
 * @param  {String} attr attribute to be created.
 * @param  initial_value Inital value for attr.
 *
 * @return {Array} List of newly created attributes names.
 *
 * ###Example
 *
 *     Person.prototype = new Class
 *     Person.prototype.constructor = Person
 *
 *     function Person() {;}
 *
 *     var me = new Person()
 *     me.create_attr( &#39;name&#39; )
 *     me.create_attr( &#39;age&#39;, &#39;height&#39; )
 *     me.create_attr( [&#39;age&#39;, &#39;height&#39;] )
 *     me.create_attr( [&#39;age&#39;, &#39;height&#39;], name, [&#39;money&#39;, &#39;studies&#39;] )
 *     me.create_attr( {name: &#39;james&#39;, age: 22} )
 *
 */
Class.prototype.create_attr = function(attributes){

   var that = this
   var effective_attributes = []

   function add_value(attr, initial_value) {
	  if (typeof(that[attr]) == &quot;undefined&quot;) {
		 initial_value = initial_value || null
		 that[attr] = initial_value
		 effective_attributes.push( attr )
	  }
   }

   for (var i=0; i&lt;arguments.length; i++){
	  var attr = arguments[i]
	  if ( String.is_string$U(attr) )
		 attr = [attr]

	  if (attr instanceof Array)
		 for (var j=0; j&lt;attr.length; j++)
	  add_value(attr[j])
	  else if (attr instanceof Object)
		 attr.self_keys().each( function(key) {
			add_value( key, attr[key] )
		 })
   }

   return effective_attributes
}

<span id='Kernel-Foundation-Architecture-Class-method-attr_reader'>/**
</span> * @method attr_reader
 *
 * Decorator function that creates attribute getters along with the attribute itself.
 * It doesn&#39;t do anything if attribute exists.
 *
 * @param  { String | Array | Object } attr_names Arrays are parsed element by element.
 *         Default values are possible passing an Object as a parameter.
 *         See Class#create_attr for further details
 *
 * ###Example
 *
 *     Person.prototype = new Class
 *     Person.prototype.constructor = Person
 *
 *     function Person() {;}
 *     me = new Person()
 *     me.attr_reader(&#39;name&#39;)
 *     me.attr_reader(&#39;age&#39;, &#39;height&#39;)
 *
 *  Then camelcased and undescored getters are provided.
 *
 *     me.get_name()
 *     me.getName()
 *
 *
 * A big todo is to achieve the class inside usage.
 *
 *     function Person() {
 *         this.attr_reader(&#39;name&#39;)
 *     }
 *
 *
 */
Class.prototype.attr_reader = function (attr_names){
   try{
	  attr_names = this.create_attr(attr_names)

	  for(var i=0; i&lt;attr_names.length; i++) {
		 name = attr_names[i]
		 this.attr_readers.push(name)
		 this[&quot;get&quot; + name.replace(name[0], name[0].toUpperCase())] = this[&quot;get_&quot; + name] = function(){ return eval(&quot;this.&quot; + name) }
	  }
   }catch(err){
	  //todo: Warn something on upper debug levels if attr_reader is not supported.
   }
}


<span id='Kernel-Foundation-Architecture-Class-method-attr_writer'>/**
</span> * @method attr_writer
 *
 * Decorator function that creates attribute setters along with the attribute itself.
 * It doesn&#39;t do anything if attribute exists.
 *
 * @param  { String | Array | Object } attr_names Arrays are parsed element by element.
 *         Default values are possible passing an Object as a parameter.
 *         See Class#create_attr for further details
 *
 * ###Example
 *
 *     Person.prototype = new Class
 *     Person.prototype.constructor = Person
 *
 *     function Person() {;}
 *     me = new Person()
 *     me.attr_writer(&#39;name&#39;)
 *     me.attr_writer(&#39;age&#39;, &#39;height&#39;)
 *
 *  Then camelcased and undescored getters are provided.
 *
 *     me.set_name(&#39;james&#39;)
 *     me.setName(&#39;jim&#39;)
 *
 */
Class.prototype.attr_writer = function (attr_names){
   try{
	  attr_names = this.create_attr(attr_names)
	  for(var i=0; i&lt;attr_names.length; i++) {
		 name = attr_names[i]
		 this.attr_writers.push(name)
		 this[&quot;set&quot; + name.replace(name[0], name[0].toUpperCase())] = this[&quot;set_&quot; + name] = function(value){ this[name] = value }
	  }
   } catch(err) {
	  //todo: Warn something on upper debug levels if attr_writer is not supported.
   }
}


<span id='Kernel-Foundation-Architecture-Class-method-attr_accessor'>/**
</span> * @method attr_accessor
 *
 * Creates an attribute along with a setter and a getter. See Class#attr_reader or Class#attr_writer.
 **
 * @param  { String | Array | Object } attr_names Arrays are parsed element by element.
 *         Default values are possible passing an Object as a parameter.
 *         See Class#create_attr for further details
 *
 * ###Example
 *
 *     Person.prototype = new Class
 *     Person.prototype.constructor = Person
 *
 *     function Person() {;}
 *     me = new Person()
 *     me.attr_accessor(&#39;name&#39;)
 *     me.attr_accessor(&#39;age&#39;, &#39;height&#39;)
 *
 */
Class.prototype.attr_accessor = function(attr_names){
   try{
	  attr_names = this.create_attr(attr_names)
	  for(var i=0; i&lt;attr_names.length; i++) {
		 name = attr_names[i]
		 this.attr_readers.push(name)
		 this.attr_writers.push(name)
		 this[&quot;get&quot; + name.replace(name[0], name[0].toUpperCase())] = this[&quot;get_&quot; + name] = function(){ return eval(&quot;this.&quot; + name) }
		 this[&quot;set&quot; + name.replace(name[0], name[0].toUpperCase())] = this[&quot;set_&quot; + name] = function(value){ this[name] = value }
	  }
   } catch(err) {
	  //todo: Warn something on upper debug levels if attr_writer is not supported.
   }
}


/*
 * Auxiliar method.
 *
 */
function _$_add_filter(where, single_param){
   if (!(single_param instanceof Array))
	  single_param = [single_param]
   for (var i=0; i&lt;single_param.length; i++)
   where.push(single_param[i])
}


<span id='Kernel-Foundation-Architecture-Class-static-method-superclass'>/**
</span> * @method superclass
 * @static
 *
 * Pointer to superclass constructor
 */
Class.superclass = function() { return null }


<span id='Kernel-Foundation-Architecture-Class-static-method-ancestors'>/**
</span> * @method ancestors
 * @static
 *
 * List of this class ancestors.
 */
Class.ancestors  = function() { return [] }

<span id='Kernel-Foundation-Architecture-Class-method-get_this'>/**
</span> * @method get_this
 * @chainable
 *
 * Returns this.
 */
Class.prototype.get_this   = function() { return this }


<span id='Kernel-Foundation-Architecture-Class-method-add_before_filter'>/**
</span> * @method add_before_filter
 *
 * Adds a function to be called before a particular method invocation..
 *
 * @param  {String} observed_function Name of the method to be wrapped.
 * @param  {function()} filters Function or functions to be called before the observed one.
 *
 * ###Example
 *
 *    var a = false;
 *    var b = 0;
 *
 *    function change(){
 *      a = true;
 *    };
 *    function Person() {;}
 *
 *    Person.prototype.greet = function (name){ return class_name };
 *
 *    me = new Person(&#39;Txema&#39;);
 *    me.add_before_filter(&#39;greet&#39;, change, function(){ b = 2 } );
 *    me.greet();
 *    a //=&gt; true
 *    b //=&gt; 2
 *
 * todo: When defined inside class it should keep track of scope. For this purpose
 * use Function#bind nowadays.
 *
 */
//todo: accept strings as argument names. Accept blocks, too.
Class.prototype.add_before_filter   = function(observed_function, filters) {
   if (typeof(this.before_filters[observed_function]) == &quot;undefined&quot;)
	  this.before_filters[observed_function] = []
   for (var i=1; i&lt;arguments.length; i++)
   _$_add_filter(this.before_filters[observed_function], arguments[i])
}

<span id='Kernel-Foundation-Architecture-Class-method-add_after_filter'>/**
</span> * @method add_after_filter
 * Adds a function to be called before a particular method invocation..
 *
 * @param  {String} observed_function Name of the method to be wrapped.
 * @param  {function()} filters Function or functions to be called after the observed one.
 *
 * ###Example
 *
 *    var a = false;
 *    var b = 0;
 *
 *    function change(){
 *      a = true;
 *    };
 *    function Person() {;}
 *
 *    Person.prototype.greet = function (name){ return class_name };
 *
 *    me = new Person(&#39;Txema&#39;);
 *    me.add_after_filter(&#39;greet&#39;, change, function(){ b = 2 } );
 *    me.greet();
 *    a //=&gt; true
 *    b //=&gt; 2
 *
 * todo: When defined inside class it should keep track of scope. For this purpose
 * use Function#bind nowadays.
 *
 */
Class.prototype.add_after_filter   = function(observed_function, filters) {

   if (typeof(this.after_filters[observed_function]) == &quot;undefined&quot;)
	  this.after_filters[observed_function] = []
   for (var i=1; i&lt;arguments.length; i++)
   _$_add_filter(this.after_filters[observed_function], arguments[i])
}

<span id='Kernel-Foundation-Architecture-Class-method-call_before'>/**
</span> * @method call_before
 *
 * Executes all the before filters for a given function. Filters
 * are executed automatically when _ClassFactory is used
 *
 * @param  {String} function_name Name of the observed method.
 *
 */
Class.prototype.call_before = function(fn_name){
   this.before_filters[fn_name] = this.before_filters[fn_name] || []
   for (var i=0; i&lt;this.before_filters[fn_name].length; i++)
   this.before_filters[fn_name][i]();
}
/* todo: define a notation in _ClassFactory to avoid filters&#39; call by default */

<span id='Kernel-Foundation-Architecture-Class-method-call_after'>/**
</span> * @method call_after
 *
 * Executes all the after filters for a given function.
 *
 * @param  {String} function_name Name of the observed method.
 */
Class.prototype.call_after = function(fn_name){
   this.after_filters[fn_name] = this.after_filters[fn_name] || []
   for (var i=0; i&lt;this.after_filters[fn_name].length; i++)
   this.after_filters[fn_name][i]();
}

<span id='Kernel-Foundation-Architecture-Class-method-method_missing'>/**
</span> * @method method_missing
 *
 * Throws an exception when a method is not defined.
 *
 * provides the following dynamic method:
 *
 * Class_&amp;lt;ClassName&amp;gt;()
 *
 * ###Example:
 *     // Create class MyClass
 *     Class_MyClass()
 *
 *     // Create class Person
 *     Class_Person(function(name){this.name = &#39;juan&#39;},
 *                  function initialize(name){ this.name = name },
 *                  function(){this.name = &#39;luis&#39;});
 *
 *
 * @param  {String} method
 * @param  {String} object
 * @param  {String} arguments
 *
 */
Class.method_missing = function(method, object, args){ throw object + &quot;.&quot; + method + &quot;(&quot; + args + &quot;) invalid method call.&quot; }


</pre>
</body>
</html>
