<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-method-capitalize'>/**
</span> * Returns a copy of str with the first character converted to uppercase and the 
 * remainder to lowercase. 
 * 
 * @memberOf    {String}
 * @method      capitalize
 * @param       (string) str 
 * @return      (String) str
 * Comments:    Case conversion is effective only in ASCII region.
 *
 **/

String.prototype.capitalize = function(){
  word = this.toLowerCase()
  return word.replace(word[0], word[0].toUpperCase())
}

String.prototype.humanize = function(){
  var word = this.strip()
  var first = word[0]
  word = word.substring(1).replace(/_+/g, &quot; &quot;).replace(/([A-Z])/g, &quot; $1&quot; ).replace(/\s+/g, &quot; &quot;)
  to_lower = word.downcase()
  return first + (to_lower? to_lower: word)
}

String.prototype.underscore = function(){
  return this.humanize().replace(/\s+_*/g, &quot;_&quot;)
}

<span id='global-method-camel_case'>/**
</span> * Returns the same string in camel case form.
 * 
 * @memberOf    {String}
 * @method      camel_case
 * @return      (String) str
 * Comments:    &quot;seek_case&quot;
 *
 **/

String.prototype.camel_case = function(){
  var sentence = &quot;&quot;
  var first = this.strip()[0]
  this.strip().split(/[\s_]+/g ).each(function(word){
    sentence += word[0].toUpperCase()
    sentence += word.substring(1)
})

  return first + sentence.substring(1)
}

String.prototype.class_name = function(){
  var sentence = &quot;&quot;
  var first = this.strip()[0]
  this.strip().split(/[\s_]+/g ).each(function(word){
    sentence += word[0].toUpperCase()
    sentence += word.substring(1)
})

  return first.toUpperCase() + sentence.substring(1)
}

<span id='global-method-index'>/**
</span> * Returns the index of the first occurrence of the given substring or pattern 
 * (regexp) in str. Returns null if not found. If the second parameter is 
 * present, it specifies the position in the string to begin the search.
 * 
 * 
 * @memberOf    {String}
 * @method      index 
 * @param       (string) str or regex
 * @return      (Number) Index of char
 * @Comments:    Returns null if not found
 * @Example:     &quot;hello&quot;.index(&quot;e&quot;) = 1 using given the parameter &quot;e&quot; the function search in the string for the first coincidence and returns its position.	    
 *
 **/

String.prototype.index = function(){
  if (arguments.length == 0 || arguments.length &gt; 2)
    //throw (&quot;wrong number of arguments&quot;)
    return null
  var pos
  var str = arguments[0].toString()
  if (arguments.length &gt; 1){
     pos = this.normalize_index(arguments[1])
     if(pos == null)
       return pos
     var find = this.substr(pos, this.length - pos)
  }
  if (str[0] == '/' &amp;&amp; str[str.length-1] == '/' &amp;&amp; str[1] == '[' &amp;&amp; str[str.length-2] == ']'){
    var min = this.length
    var entradoAlMenosUnaVez = false
    for(var i=2;i&lt;str.length - 2; i++)
      if (min &gt;= find.search(str[i]) &amp;&amp; find.search(str[i]) &gt;= 0){
         min = find.search(str[i])+pos
         entradoAlMenosUnaVez = true
         }
    return min &gt;= 0 &amp;&amp; entradoAlMenosUnaVez? min : null
  }
  return this.indexOf(arguments[0]) &lt; 0? null : this.indexOf(arguments[0])
// Falta que funcione al pasar por parametros
// ? y una letra, ya que da error de sintaxis
}

<span id='global-method-normalize_index'>/**
</span> * Returns a index of the string 
 * 
 * 
 * @memberOf    {String}
 * @method      normalize_index
 * @param       (Number) 
 * @return      (Number) 
 * Comments:    In case of abs of number more than this.length, return null else return index
 *
 **/


String.prototype.normalize_index = function(){
  if (typeof(arguments[0]) === &quot;number&quot;)
     if (arguments[0] &lt; 0? Math.abs(arguments[0]) &lt;= this.length:Math.abs(arguments[0]) &lt;= this.length - 1)
      return arguments[0] &lt; 0? arguments[0] + this.length : arguments[0]
  return null
}

<span id='global-method-insert'>/**
</span> * Inserts other_str before the character at the given index, modifying str.
 * Negative indices count from the end of the string, and insert after the 
 * given character. The intent is insert aString so that it starts at the given index.
 * 
 * 
 * @memberOf    {String}
 * @method      insert 
 * @param       (string) str
 * @return      (String) str
 * Comments:    giving the position and a new string the function will insert the new string next to the given position.
 * @example:  &quot;hello&quot;.insert(2, &quot;jaja&quot;) -&gt; hejajallo 
 * 
 **/

String.prototype.insert = function(){
  if (arguments.length == 0 || arguments.length &gt; 2)
    //throw (&quot;wrong number of arguments&quot;)
    return null
  if (arguments[0] == this.length)
    return this + arguments[1]
  else if (arguments[0] == -(this.length + 1))
    return arguments[1] + this
  var pos = arguments[0] &gt;= 0? this.normalize_index(arguments[0]) : this.normalize_index(arguments[0]) + 1
  if (this.normalize_index(arguments[0]) == null)
    return null
    //throw(&quot;index out of string&quot;)
  var str = &quot;&quot;
  for(var i=0;i&lt;=this.length;i++)
     if(i == pos){
       str = str + arguments[1]
       var add = true
     }
     else if(!i==0 &amp;&amp; add)
       str = str + this[i - 1]
          else
            str = str + this[i]
  return str
}

<span id='global-method-ljust'>/**
</span> * If integer is greater than the length of str, returns a new String of length 
 * integer with str left justified and padded with padstr; otherwise, returns str.
 * 
 * 
 * @memberOf    {String}
 * @method      ljust
 * @param       (string) str
 * @return      (String) str
 * Comments:    Adjust the posision of the parameter extending it to the max position
 * @example: &quot;hello&quot;.ljust(10,&quot;p&quot;) -&gt; helloppppp
 **/

String.prototype.ljust = function(){
  var str = this
  var j = 0
  for(var i = 0; i &lt; (arguments[0] - this.length); i++)
    if (arguments.length &gt; 1 &amp;&amp; arguments[1].length &gt; 1)
      str = str + arguments[1][i % arguments[1].length]
    else if (arguments.length &gt; 1)
        str = str + arguments[1]
        else
         str = str + &quot; &quot;
  return str
}

<span id='global-method-lstrip'>/**
</span> * Returns a copy of str with leading whitespace removed. See also String#rstrip
 * and String#strip. 
 * 
 * 
 * @memberOf    {String}
 * @method      lstrip 
 * @param       (string) str
 * @return      (String) str
 * @Comments:    
 * @example 
 *
 **/

String.prototype.lstrip = function(){
  return this.replace(/^\s+/g,&quot;&quot;)
}

<span id='global-method-swapcase'>/**
</span> * Returns a copy of str with uppercase alphabetic characters converted to lowercase
 * and lowercase characters converted to uppercase.
 * 
 * 
 * @memberOf    {String}
 * @method      swapcase 
 * @param       (string) str
 * @return      (String) 
 * Comments:    Case conversion is effective only in ASCII region.   
 * @example &quot;Hello&quot;.swapcase() -&gt; hELLO
 *
 **/

String.prototype.swapcase= function(){
  var str = []
  for(var i = 0; i &lt; this.length;i++){
    if ((this[i].charCodeAt(0) &gt; 64) &amp;&amp; (this[i].charCodeAt(0) &lt; 97)){      
      str[i] = this[i].toLowerCase()      
    }
    else{
      str[i] = this[i].toUpperCase()
    }
  }  
  var word = str.join(&quot;&quot;)
  return word
}

<span id='global-property-'>/**
</span> * Returns true if self contains no elements
 *
 *
 * @ memberOf   { String }
 * @ method     empty$ return a boolean true if this is empty 
 * @ param      {String}
 * @ return     (bool)  true = this is empty  false = this is not empty
 * Comments:     asks if the variable contains values
 *
 * &quot;hello&quot;.empty$U()   #=&gt; false
 * &quot;&quot;.empty$U()        #=&gt; true
 *
 **/
String.prototype.empty$U = function(){
   if(arguments.length &gt; 0)	
      //throw (&quot;wrong number of arguments. This function not needs arguments&quot;)
      return null
   return this.length&gt;0? false : true
}

<span id='global-property-'>/**
</span> * Returns a copy of str with all uppercase letters replaced with their lowercase counterparts.
 * The operation is locale insensitive—only characters &quot;A&quot; to &quot;Z&quot; are affected. 
 * Note: case replacement is effective only in ASCII region
 * Ths method use a &quot;toLowerCase()&quot; function
 *
 * @ memberOf   {String}
 * @ method     downcase
 * @ param      {String}
 * @ return     Return this modificed with character Ascii of this downcase
 * 
 * Comments:    turns everything to downcase.
 * @example: &quot;hEllO&quot;.downcase()   #=&gt; &quot;hello&quot;
 *           &quot;hello&quot;.downcase()   #=&gt;  null
 *
 *
 **/

String.prototype.downcase = function(){
   return this.toLowerCase() == this? null : this.toLowerCase() 
}

<span id='global-property-'>/**
</span> * Compares two strings and returns 0 if the two strings are equals.
 * If the first string (argument) is different returns 1.
 * If the second string (this) is different returns -1. 
 *
 *
 * @ memberOf   {String}
 * @ method     casecmp 
 * @ param      (void)
 * @ return     (Number) Returns -1 (lower than), 0 (equals), 1 (greater than)
 * Comments: 
 * Case-insensitive version of ruby String#&lt;=&gt;.
 *
 *    &quot;abcdef&quot;.casecmp(&quot;abcde&quot;)     #=&gt; 1
 *    &quot;aBcDeF&quot;.casecmp(&quot;abcdef&quot;)    #=&gt; 0
 *    &quot;abcdef&quot;.casecmp(&quot;abcdefg&quot;)   #=&gt; -1
 *    &quot;abcdef&quot;.casecmp(&quot;ABCDEF&quot;)    #=&gt; 0
 *
 *
 **/

String.prototype.casecmp = function(){
  
  if (arguments.length &lt; 1)
   throw(&quot;ArgumentError: Wrong number of arguments&quot;)
  var str1 = this.toLowerCase()
  var str2 = arguments[0].toLowerCase() 
  return ( ( str1 == str2 ) ? 0 : ( ( str1 &gt; str2 ) ? 1 : -1 ) );

}

<span id='global-method-ord'>/**
</span> * This function return the integer ordinal of a one-character string.
 *
 * @memberOf     {String}   
 * @method       ord        
 * @param        (String)  One letter only from ASCII code. 
 * @return       (String)     
 *
 * Comments:   This function works using a javascript function(.charCodeAt).
 **/

String.prototype.ord = function(){
   return this.charCodeAt(0)
}

<span id='global-method-oct'>/**
</span> * This function make an octal value from a number.
 *
 * @memberOf     {String}   
 * @method       oct        
 * @param        (String)     Number between -7 and 7 and discard the rest.
 * @return       (String)     Return an octal value .
 *
 * Comments: This function works using a javascript function(parseInt).Returns
 * a copy of str with uppercase alphabetic characters converted to lowercase and
 * lowercase characters converted to uppercase. Note: case conversion is effective
 * only in ASCII region.
 *
 * @example      
 *  
 **/

String.prototype.oct = function(){
  oct = this.match( /^[(-7)-7]+/)
  oct= oct || [&quot;0&quot;]
  return parseInt(oct[0], 8)
}

<span id='global-method-reverse'>/**
</span> * This function returns a reverse from an introduced string
 *
 * @memberOf     {String}     
 * @method       reverse      
 * @return       (String)     Return the reverse from a string.
 *
 * Comments: This function use a &quot;.reverse&quot; from array class.
 **/

String.prototype.reverse = function(){
   return this.split(&quot;&quot;).reverse().join(&quot;&quot;)
}

<span id='global-method-include'>/**
</span> * Returns true if str contains the given string or character.
 *
 * @memberOf     {String}     
 * @method       include     
 * @return       True o false
 *
 * Comments:     respond if the atribute given is contained in the variable
 **/

String.prototype.include$U = function(){
   return (this.lastIndexOf(arguments[0]) &gt; -1)? true : false 
}

// Can receive comma separated strings or an array
String.prototype.include_some_of$U = function(){
   var included = false
   for (var i=0; i&lt;arguments.length; i++){
     if (typeof(arguments[i]) == &quot;string&quot;)
        included = included || this.include$U(arguments[i])
     if (arguments[i] instanceof Array)
        included = included || String.prototype.include_some_of$U.apply(this, arguments[i])
   }
   return included
}

<span id='global-method-center'>/**
</span> * This function returns a center word in the string
 *
 * @memberOf     {String}     
 * @method       center      
 * @return       (String)     Return the a string with a word center.
 *
 * Comments: 
 *
 **/

String.prototype.rindex = function(){
   if (arguments.length == 0)
      return null
   return (this.lastIndexOf(arguments[0]) &gt; 0)? this.lastIndexOf(arguments[0]) : false
}

<span id='global-method-center'>/**
</span> * This function returns a center word in the string
 *
 * @memberOf     {String}     
 * @method       center      
 * @return       (String)     Return the a string with a word center.
 *
 * Comments: If integer is greater than the length of str, returns a new String of length integer with str centered and padded with padstr; otherwise, returns str.

   @example:

   &quot;hello&quot;.center(4)         #=&gt; &quot;hello&quot;
   &quot;hello&quot;.center(20)        #=&gt; &quot;       hello        &quot;
   &quot;hello&quot;.center(20, '123') #=&gt; &quot;1231231hello12312312&quot;
 **/

String.prototype.center = function(){
 if (arguments.length == 0 || arguments.length &gt; 2)
     throw(&quot;wrong number arguments&quot;)
  if (this.length &gt;= arguments[0])
     return this
  var str = &quot;&quot; 
  var i = 0
  var j = 0
  while(i&lt;=(arguments[0] - this.length)){
      if (i == (arguments[0]-this.length) / 2){
         j = 0
         str += this
         }
      else if (arguments.length &gt; 1){
         str += arguments[1].length == 1? arguments[1] : arguments[1][j]
         j = (j+1)%arguments[1].length
         }
           else
              str += &quot; &quot;
      i++
  } 
  return str
}

<span id='global-method-chomp'>/**
</span> * This function return a string without \n or \r or \r\n of the end.
 *
 * @memberOf     {String}     
 * @method       chomp     
 * @return       (String)
 *
 * Comments: Returns a new String with the given record separator removed from the end of str (if present). If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is it will remove \n, \r, and \r\n).

   &quot;hello&quot;.chomp()            #=&gt; &quot;hello&quot;
   &quot;hello\n&quot;.chomp()          #=&gt; &quot;hello&quot;
   &quot;hello\r\n&quot;.chomp()        #=&gt; &quot;hello&quot;
   &quot;hello\n\r&quot;.chomp()        #=&gt; &quot;hello\n&quot;
   &quot;hello\r&quot;.chomp()          #=&gt; &quot;hello&quot;
   &quot;hello \n there&quot;.chomp()   #=&gt; &quot;hello \n there&quot;
   &quot;hello&quot;.chomp(&quot;llo&quot;)       #=&gt; &quot;he&quot;


 **/


String.prototype.chomp = function(){
    if (arguments.length == 1)
       return this.replace(arguments[0], &quot;&quot;)
    if (this.search(/\r\n/i) == this.length - 2)
       return this.replace(&quot;\r\n&quot;, &quot;&quot;)
    if (this.search(/\r/i) == this.length - 1)
       return this.replace(&quot;\r&quot;, &quot;&quot;)
    if (this.search(/\n/i) == this.length - 1)
       return this.replace(&quot;\n&quot;, &quot;&quot;)
    return this
}

<span id='global-method-chop'>/**
</span> * This function return a string without \n or \r or \r\n or char of the end the String.
 *
 * @memberOf     {String}     
 * @method       chop     
 * @return       (String)
 *
 * Comments: Returns a new String with the last character removed. If the string ends with \r\n, both characters are removed. Applying chop to an empty string returns an empty string. String#chomp is often a safer alternative, as it leaves the string unchanged if it doesn‘t end in a record separator.

 @example
   &quot;string\r\n&quot;.chop()   #=&gt; &quot;string&quot;
   &quot;string\n\r&quot;.chop()   #=&gt; &quot;string\n&quot;
   &quot;string\n&quot;.chop()     #=&gt; &quot;string&quot;
   &quot;string&quot;.chop()       #=&gt; &quot;strin&quot;
   &quot;x&quot;.chop.chop()       #=&gt; &quot;&quot;
 
 **/


String.prototype.chop = function(){
  if (arguments.length &gt; 0)
//     throw(&quot;wrong number of arguments&quot;)
    return null
  var str = this.chomp()
  if (str.length == this.length)
    return str.slice(0,this.length-1)
  return str
}

<span id='global-method-hex'>/**
</span> * This function return a number hexadecimal convert to decimal.
 *
 * @memberOf     {String}     
 * @method       hex     
 * @return       (Number)
 *
 * Comments: Treats leading characters from str as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number. Zero is returned on error.

   &quot;0x0a&quot;.hex()     #=&gt; 10
   &quot;-1234&quot;.hex()    #=&gt; -4660
   &quot;0&quot;.hex()        #=&gt; 0
   &quot;wombat&quot;.hex()   #=&gt; 0


 **/

String.prototype.hex = function(){
   if (this.search(&quot;0x&quot;) == 0) 
     return parseInt(this)
   return isNaN(parseInt(this,16))? 0 : parseInt(this,16)
}

<span id='global-method-chr'>/**
</span> * This function return first char of the string.
 *
 * @memberOf     {String}     
 * @method       chr     
 * @return       (Char)
 *
 * Comments: Returns a one-character string at the beginning of the string.

   a = &quot;abcde&quot;
   a.chr()    #=&gt; &quot;a&quot;

 **/

String.prototype.chr = function(){
// No se puede coger el numero que se 
// mete en this y sacar un string con la conversion en hexadecimal
// Problema: this no puede ser un valor decimal en esta clase, ya que
// solo deja meter strings
  if (this.length &gt; 1)
     return this[0]
  return this
}

<span id='global-method-rjust'>/**
</span> * If integer is greater than the length of str, returns a new String of length integer with str right justified and padded with padstr; otherwise, returns str.  
 *
 * @memberOf     {String}     
 * @method       rjust     
 * @return       (String) str
 *
 * Comments: 

   &quot;hello&quot;.rjust(4)            #=&gt; &quot;hello&quot;
   &quot;hello&quot;.rjust(20)           #=&gt; &quot;               hello&quot;
   &quot;hello&quot;.rjust(20, '1234')   #=&gt; &quot;123412341234123hello&quot;

 **/

String.prototype.rjust = function(){
  if (this.length &gt;= arguments[0])
     return this
  var str = &quot;&quot;
  var i = 0
  while(i&lt;(arguments[0] - this.length)){
       if (arguments.length &gt; 1){
         str += arguments[1].length == 1? arguments[1] : arguments[1][i%arguments[1].length]
         }
       else
         str += &quot; &quot;
      i++
  }
  return str+this
}

<span id='global-method-succ'>/**
</span> * Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set‘s collating sequence.  
 *
 * @memberOf     {String}     
 * @method       succ     
 * @return       (String) str
 *
 * Comments: If the increment generates a ``carry,’’ the character to the left of it is incremented. This process repeats until there is no carry, adding an additional character if necessary.

   &quot;abcd&quot;.succ()        #=&gt; &quot;abce&quot;
   &quot;THX1138&quot;.succ()     #=&gt; &quot;THX1139&quot;
   &quot;&lt;&lt;koala&gt;&gt;&quot;.succ()   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
   &quot;1999zzz&quot;.succ()     #=&gt; &quot;2000aaa&quot;
   &quot;ZZZ9999&quot;.succ()     #=&gt; &quot;AAAA0000&quot;
   &quot;***&quot;.succ()         #=&gt; &quot;**+&quot;
 
 **/

String.prototype.succ = function(){
  var str = &quot;&quot;
  var i
  var vuelta = true
  for(i=this.length-1;i&gt;=0 &amp;&amp; vuelta;i--){
    if (this[i] == '&gt;' || this[i] == '&lt;')
       str = this[i] + str
    else if(this[i]=='z' || this[i]=='Z')
            str = (this[i]=='z'? 'a':'A') + str
         else if(this[i] == '9')
                 str = '0' + str
              else
                 str = String.fromCharCode(this[i].charCodeAt()+1) + str
  vuelta =this[i] == 'z' || this[i] == 'Z' || this[i]=='9' || this[i]=='&lt;' || this[i]=='&gt;'
}
  if (this[0] == '&lt;' &amp;&amp; i &lt; 0 &amp;&amp; (this[2] == 'z' || this[2] == 'Z'))
     return &quot;&lt;&lt;&quot; + str[2] + str.substr(2,str.length-2)
  else if (this[0] == '&lt;' &amp;&amp; i &lt; 0 &amp;&amp; this[2] == '9')
     return &quot;&lt;&lt;&quot; + str[2].succ() + str.substr(2,str.length-2)
  return i &lt; 0 &amp;&amp; (this[0]=='z' || this[0]=='Z')? str[0] + str : i &lt; 0 &amp;&amp; this[0] == '9'? str[0].succ() + str : this.substr(0,i+1)+str
}
<span id='global-method-next'>/**
</span> *  Alias of the function succ.
 * 
 * @memberOf     {String}     
 * @method       next     
 * @return       (String) str      
 *
 **/ 
String.prototype.next = function(){
   return this.succ.apply(this,arguments)
}

<span id='global-property-'>/**
</span> * Returns the result of interpreting leading characters in str as an integer base base (between 2 and 36).
 * Extraneous characters past the end of a valid number are ignored. 
 * If there is not a valid number at the start of str, 0 is returned. 
 * This method never raises an exception when base is valid. 
 *
 * @ member   {String}
 * @ method   to_i
 * @ param    (int) -&gt; is a base (2 - 36), or 0 who is the same that 10
 *
 * @ return    Return a int if the string and paremeters are correct. Return 0 if string or parameter are incorrect
 * 
 * &quot;12345&quot;.to_i()             #=&gt; 12345
 * &quot;99 red balloons&quot;.to_i()   #=&gt; 99
 * &quot;0a&quot;.to_i()                #=&gt; 0
 * &quot;0a&quot;.to_i(16)            #=&gt; 10
 * &quot;hello&quot;.to_i()             #=&gt; 0
 * &quot;1100101&quot;.to_i(2)        #=&gt; 101
 * &quot;1100101&quot;.to_i(8)        #=&gt; 294977
 * &quot;1100101&quot;.to_i(10)       #=&gt; 1100101
 * &quot;1100101&quot;.to_i(16)       #=&gt; 17826049
 *
 **/
String.prototype.to_i = function() {
var base = 10 //Base por defecto
var result = 0 //Resultado por defecto

      //Exception
if(arguments.length &gt; 1)
   //throw (&quot;wrong number of arguments. to_i( [base: 2 ... 36]) &quot;)
   return null

if(arguments.length != 0)
    if(isNaN(arguments[0]) || (arguments[0] &lt; 2) || (arguments[0] &gt; 36))
       //throw (&quot;Invalid argument for base (2 - 36)&quot;)
       return null
    else base = arguments[0]

return isNaN( parseInt(this,base) )? 0 : parseInt(this,base) 
}


<span id='global-property-'>/**
</span> * Returns the result of interpreting leading characters in str as a floating point number
 *
 * @ memberOf {String}String.prototype.prueba = function(){
 * return this.replace(arguments[0], arguments[1]) 
 * }
 * var i=&quot;hello&quot;
 * i.prueba(/[aeio]/,&quot;+&quot;)
 * @ method   to_f	//Returns the result of interpreting leading characters in str as a floating point number
 * @ param    (void)    //No parameters
 *
 * @ return   Float -&gt;  //Returns a float numbers if string is a number. Return 0.0 if a string is not a number
 *
 * &quot;123.45e1&quot;.to_f()        #=&gt; 1234.5
 * &quot;45.67 degrees&quot;.to_f()   #=&gt; 45.67
 * &quot;thx1138&quot;.to_f()         #=&gt; 0.0
 *
 **/
String.prototype.to_f = function() {
  //Exception
  if(arguments.length &gt; 0)
    //throw (&quot;This function no needs arguments&quot;)
    return null

  return isNaN(parseFloat(this))? 0.0 : parseFloat(this) ;
}

<span id='global-method-'>/**
</span> * Returns a copy of str with leading and trailing whitespace removed. 
 *
 * @ memberOf {String}
 * @ method   strip
 * @ param    (void)
 *
 * @return  String -&gt; Return a copy of str with leading and trailing whitespace removed
 *
 * &quot;    hello    &quot;.strip()   #=&gt; &quot;hello&quot;
 * &quot;\t goodbye\r\n&quot;.strip()   #=&gt; &quot;goodbye&quot;
 *
 **/
String.prototype.strip = function() {
  return this.lstrip().rstrip()
}


String.prototype.setbyte = function(){
     var that = this.split(&quot;&quot;)
     if(arguments[0] &lt; that.length) 
       that[arguments[0]] = String.fromCharCode(arguments[1])
     else
	//throw(&quot;Wrong index&quot;) 
       return null
     str = &quot;&quot;
     for(var i = 0; i &lt; that.length; i++)
      str += that[i]    
 return str
}

<span id='global-method-partition'>/**
</span> * Searches sep or pattern (regexp) in the string and returns the part before it, the match, and the part after it. If it is not found, returns two empty strings and str.
 * 
 * @memberOf     {String}     
 * @method       partition     
 * @return       (Array) ary
 *
 * Comments: 

   &quot;hello&quot;.partition(&quot;l&quot;)         #=&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]
   &quot;hello&quot;.partition(&quot;x&quot;)         #=&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]
   &quot;hello&quot;.partition(/.l/)        #=&gt; [&quot;h&quot;, &quot;el&quot;, &quot;lo&quot;]

 **/


String.prototype.partition = function(){
     var ary = [3]
     var str = arguments[0].toString()
     var pos = this.search(arguments[0]) 
     if (pos &lt; 0)
         ary = [this.substr(0,this.length), &quot;&quot;, &quot;&quot;]
     else if (str[0] == '/' &amp;&amp; str[str.length-1] == '/')
              ary = [this.substr(0, pos), this.substr(pos,str.length-2),this.substr(pos+str.length - 2,this.length-pos)]
          else
              ary = [this.substr(0, pos), this.substr(pos,str.length),this.substr(pos+str.length,this.length-pos)]
     return ary
}

<span id='global-method-'>/**
</span> * Returns a copy of str with trailing whitespace removed. 
 *
 * @ memberOf {String}
 * @ method   rstrip
 * @ param    (void)
 *
 * @return  String Return a copy of str with trailing whitespace removed
 *
 **/
String.prototype.rstrip = function(){
  return this.replace(/\s+$/g,'')
}
<span id='global-method-'>/**
</span> * Iterates through successive values, starting at str and ending at other_str inclusive, passing each value in turn to the block. The String#succ method is used to generate each value. If optional second argument exclusive is omitted or is false, the last value will be included; otherwise it will be excluded.                  
 *
 *
 * @ memberOf {String}
 * @ method   upto
 * @ param    (String, function)
 *
 * @return    return string with succ of this to arguments[0], according to parameter function
 *
 * @Comments: 
 *
 * If no block is given, an enumerator is returned instead.
 *
 *         &quot;a8&quot;.upto(&quot;b6&quot;, function(obj){return obj + ' '}) 
 *
 *               produces:
 *
 *          a8 a9 b0 b1 b2 b3 b4 b5 b6
 *          a8 a9 b0 b1 b2 b3 b4 b5 b6 
 *
 **/
String.prototype.upto = function(){ 
   var num = this
   var str = &quot;&quot;
   while( num != arguments[0] &amp;&amp; num.length &lt;= arguments[0].length &amp;&amp; num &lt; arguments[0] ){
     str += String.prototype.upto.yield(num)
     num = num.succ()
   }
   if( num.length &gt; arguments[0].length )
     return str  
   return str + String.prototype.upto.yield(num)
}

<span id='global-method-'>/**
</span> * Passes each character in str to the given block, or returns an enumerator if no block is given.  
 *
 * @ memberOf {String}
 * @ method   each_char
 * @ param    (function)
 *
 * @return   return a string according function
 *
 * @Comments: 
 *
 *    &quot;hello&quot;.each_char(function(){return obj + ' '})
 *
 *       produces:
 *
 *    &quot;h e l l o &quot;
 *
 *
 **/
String.prototype.each_char = function(){
   var str = &quot;&quot;
   for (var i = 0; i&lt;this.length;i++)
      str += String.prototype.each_char.yield(this[i]) 
   return str
}
<span id='global-method-chars'>/**
</span> *  Alias of the function each_char.
 * 
 * @memberOf     {String}     
 * @method       chars     
 * @return       (String) str      
 *
 **/ 
String.prototype.chars = function(){
   return this.each_char.apply(this, arguments)
}

String.prototype.sum = function(){
  var suma = 0
  for (var i = 0; i&lt;this.length;i++)
     suma += this.charCodeAt(i)
  return suma
}

<span id='global-property-'>/**
</span> * Returns a string where runs of the same character that occur in this set are replaced by a single character.
 *
 * @ memberOf {String}
 * @ method   squeeze
 * @ param    () 
 * @ param    (String) Remove only the repeated characters in the string contents.
 *Returns a copy of str with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase. Note: case conversion is effective only in ASCII region. 
 * 
 * @ return  String Returns a copy  where runs of the same character that occur in this set are replaced by a single character.
 *
 *
 **/
//Falta que coja el argumento (&quot;x-y&quot;)
/*
String.prototype.squeeze = function(){ 
   var strng = this 
      if (arguments.length == 0){ 
	    for(var i=0; i&lt;strng.length - 1; i++) 
	      while (strng[i] == strng[i+1]) 
	        strng = (strng.slice(0, i+1)).concat(strng.slice(i+2))
		  return strng
      }
                  
      if(arguments.length &gt; 0){                
        for(j = 0; j &lt; arguments.length; j++){  
          var dwords = &quot;&quot;
          for(var k = 0; k &lt; arguments[j].length; k++)
            if(arguments[j][k] == &quot;-&quot;)
              if(arguments[j][k-1] &lt;  
                


	  for (var arg = 0; arg&lt;arguments[j].length ; arg++) 
	    for(var i=0; i&lt;strng.length - 1; i++) 
	      while (strng[i] == strng[i+1] &amp;&amp; strng[i] == arguments[j][arg]) 
	        strng = (strng.slice(0, i+1)).concat(strng.slice(i+2)) 
        } 
      }
        
   return strng
}
*/

<span id='global-method-String'>/**
</span> * Returns a string containing common letters in the parameter strings
 * 
 * @memberOf    {String}
 * @method	String#intersection
 * @param	(String) character_list List of characters to be deleted
 * @return      (String)
 
 * Comments:   When more thas one params are given, tt match the first  parameter given, then  these letters are changed  by the given characterhey're firstly intersected.
 * 	       Otherways the first param is returned.
 * 
 **/

String.prototype.intersection = function(){
      var str = this
      for (var i=0; i&lt;arguments.length; i++){
	 var regex = &quot;[&quot; + arguments[i] + &quot;]&quot;
	 str = str.match( new RegExp(regex , &quot;g&quot; )).join(&quot;&quot;)
      }
      return str
}

<span id='global-method-sub'>/**
</span> * Returns a copy of string with the first occurrence of pattern substituted for the second argument.
 * 
 * @memberOf    {String}
 * @method	sub
 * @param	(RegEx,string) 
 * @return      (String)
 * Comments:    Find the letters that match the first parameter given, y these are changed by the given parameter.
 *
 **/

String.prototype.sub= function(){
   return this.replace(arguments[0], arguments[1]) 
}

<span id='global-method-'>/**   
</span> * Passes each byte in str to the given block, or returns an enumerator if no block is given.
 * 
 * @ memberOf {String}
 * @ method   bytes
 * @ param    ()
 *
 * @return 
 * 
 **/
String.prototype.bytes = function(){
  for(var i = 0; i &lt; this.length; i++)
    return this.charCodeAt(i)
}

<span id='global-method-'>/**
</span> * Returns true for a string which has only ASCII characters. 
 *
 * @ memberOf {String}
 * @ method   ascii_only$U
 * @ param    (void)
 *
 * @return true or false
 * 
 **/

String.prototype.ascii_only$U = function(){
     return isNaN(this)
}

<span id='global-method-'>/**
</span> * Splits str using the supplied parameter as the record separator.
 * passing each substring in turn to the supplied block. 
 * If a zero-length record separator is supplied, the string is split 
 * into paragraphs delimited by multiple successive newlines. 
 *
 * @ memberOf {String}
 * @ method   each_line
 * @ param    ([ string | number ],function { } ) 
 *
 * @return str split by separator
 *
 * &quot;Hello\nworld&quot;.each_line(function(obj){return &quot;&quot; + obj + &quot;&quot;})            =&gt; &quot;Hello\n&quot;,&quot;world&quot;
 * &quot;Hello\n world&quot;.each_line(&quot;l&quot;,function(obj){return &quot;&quot; + obj + &quot;&quot;}))      =&gt; &quot;Hel&quot;, &quot;l&quot;, &quot;o \\n worl&quot;, &quot;d&quot;
 * &quot;Hello \n\n\n world&quot;.each_line(&quot;&quot;,function(obj){return &quot;&quot; + obj + &quot;&quot;}))  =&gt; &quot;Hello \\n\\n\\n&quot;,&quot; world&quot;
 **/
String.prototype.each_line = function(){
var ary = this
var arycpy = []  //ary with string result
var posEnd = 0		//position to split the origin string
var ind = 0			//index for ary
var regExp = /\n/g	
var argZero = false	//Indicates if the arguments zero is a &quot;&quot;

if(arguments.length == 0 || arguments.length &gt; 2)
   return null

if( typeof(arguments[0]) !== &quot;function&quot; ){
   if(arguments[0] != &quot;&quot;)
      regExp = RegExp(arguments[0])
   else {
      regExp = /\n{2,}/g
      argZero = true
	}
}
posEnd = ary.search(regExp) + 1 
while( (posEnd &lt; ary.length) &amp;&amp; (posEnd &gt;0) ){
   if(argZero){
      var trash = ary.substring(posEnd)
      posEnd += trash.search(/./g)
   }
   arycpy[ind] = ary.substring(0, posEnd)
   ary = ary.substring(posEnd)
   arycpy[ind] = ary.each_line.yield(arycpy[ind])
   ind++
   posEnd = ary.search(regExp) + 1
}
ary = ary.substring(posEnd)
ary.each_line.yield(ary) 
return this
}

<span id='global-method-'>/**
</span> * Passes the Integer ordinal of each character in str, also known as a codepoint when applied to Unicode strings to the given block.
 *
 * If no block is given, an enumerator is returned instead.  
 *
 * @ memberOf {String}
 * @ method   each_codepoint
 * @ param    (function)
 *
 * @return return a string according function. 
 *
 * @Comments: 
 *
 *    &quot;hello\u0639&quot;.each_codepoint(function(){return obj + ' '})
 *
 *       produces:
 *
 *    &quot;104 101 108 108 111 1593 &quot;
 *
 **/

String.prototype.each_codepoint = function(){
  var str = &quot;&quot;
  for (var i=0;i&lt;this.length;i++)
      str += String.prototype.each_codepoint.yield(this[i].charCodeAt(0))
  return str
}
<span id='global-method-codepoint'>/**
</span> *  Alias of the function each_codepoint.
 * 
 * @memberOf     {String}     
 * @method       codepoint     
 * @return       (String) str of digits ASCII     
 *
 **/ 
String.prototype.codepoint = function(){
  return this.each_codepoint.apply(this,arguments)
}
<span id='global-method-rpartition'>/**
</span> * Searches sep or pattern (regexp) in the string from the end of the string, and returns the part before it, the match, and the part after it. If it is not found, returns two empty strings and str. 
 * 
 * @memberOf     {String}     
 * @method       rpartition     
 * @return       (Array) ary
 *
 * Comments:

   &quot;hello&quot;.rpartition(&quot;l&quot;)         #=&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]
   &quot;hello&quot;.rpartition(&quot;x&quot;)         #=&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]
   &quot;hello&quot;.rpartition(/.l/)        #=&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]
 
 **/

String.prototype.rpartition = function(){
     var ary = [3]
     var str = arguments[0].toString()
     if (this.search(arguments[0]) == -1){
        ary = [&quot;&quot;,&quot;&quot;,this.substr(0,this.length)]
        return ary
}
     else{
     auxstr = str.substr(2,str.length-3)
     var pos = str[0] == '/' &amp;&amp; str[str.length-1] == '/'? this.lastIndexOf(auxstr):this.lastIndexOf(str)
     if (str[0] == '/' &amp;&amp; str[str.length-1] == '/')
              ary = [this.substr(0, pos-1), this.substr(pos-1,auxstr.length+1),this.substr(pos+auxstr.length ,this.length-pos)]
          else
              ary = [this.substr(0, pos), this.substr(pos,str.length),this.substr(pos+str.length,this.length-pos)]
     }
     return ary
}

<span id='global-method-'>/**
</span> *
 * The match() method searches for a match between a regular expression and a string, and returns the matches.
 * This method returns an array of matches, or null if no match is found.Returns a copy of str with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase. Note: case conversion is effective only in ASCII region. 
 *
 * @ memberOf {String}
 * @ method scan  
 * @ param   string 
 *
 * @return string
 * 
 **/

String.prototype.scan = function(){
   var ary = this.match(arguments[0])
   if (ary.length &gt; 1 &amp;&amp; arguments.length &lt;2) 
      ary.shift()
   if ( arguments.length &gt; 1 &amp;&amp; typeof(arguments[1]) === &quot;function&quot; ){
     ary = this
     
     while( ary.length &gt; 0 &amp;&amp; ary.search(arguments[0]) != -1){
       var finds = []
       var find = ary.match(arguments[0])
       ary = ary.replace(arguments[0], &quot;&quot;)
       for (var i=1; i&lt;9; i++)
         if (RegExp[&quot;$&quot; + i] != &quot;&quot;)
           finds.push(RegExp[&quot;$&quot; + i])
       if (finds.length == 0)
         finds = find
       arguments[1].apply(arguments[1], finds)
     }
     return this
   }
   return ary
}

<span id='global-method-erase'>/**
</span> *  Returns a new string with erased letters.
 *
 * @memberOf    {String}
 * @method      erase
 * @param       (string) str
 * @return      (String)
 * Comments:    Erases the arguments matched in a string.
 *
 **/
String.prototype.erase = function(){
   var erase = this
   for(var i = 0; i &lt; arguments.length; i++)
      erase = this.intersection(erase, arguments[i])
   var regex = &quot;[^&quot; + erase + &quot;]&quot;
   erase = this.match(new RegExp(regex, &quot;g&quot;)).join(&quot;&quot;)
   return erase
}

<span id='global-method-end_WithS-U'>/**
</span> *  Returns true or false by comparing  object and the argument from the end.
 * 
 * @memberOf    {String}
 * @method      end_With$U
 * @param       (string) str
 * @return      (String)  true or false
 * Comments:    Compares the object with argument.
 *
 **/

String.prototype.end_With$U = function(str){
    return (this.match(str+&quot;$&quot;)==str)}
     
<span id='global-method-eqlS-U'>/**
</span> * Returns true or false by comparing  object and the argument.
 * 
 * @memberOf    {String}
 * @method      eql$U
 * @param       (string)
 * @return      (String)  true or false
 * Comments:    Compares the object with argument.
 *
 **/
     
String.prototype.eql$U = function() {
    return this == arguments[0]}

<span id='global-method-getbyte'>/**
</span> * Returns the indexth byte as an integer. 
 * 
 * @memberOf    {String}
 * @method      getbyte
 * @param       (string)   
 * @return      (String)  a interger.
 * 
 * Comments:    Using charCodeAt from a javaScript function.
 **/


String.prototype.getbyte = function(){
    return this.charCodeAt(arguments[0])
}



String.prototype.to_str = function(){
    return this.toString()
}

<span id='global-property-'>/** Returns a rational which denotes the string form.
</span> * The parser ignores leading whitespaces and trailing garbage. 
 * Any digit sequences can be separated by an underscore. 
 * Returns zero for null or garbage string. 
 *
 * @ memberOf   { String }
 * @ method	to_r
 * @ param	(string)
 *  
 * @ return     (string)  Return a rational
 *			 If the arguments is invalid return &quot;0/1&quot; 
 *                       Returns a copy of str with uppercase alphabetic characters 
 *                       converted to lowercase and lowercase characters converted to uppercase.
 *
 * '  2  '.to_r()       #=&gt; (2/1)
 * '300/2'.to_r()       #=&gt; (150/1)
 * '-9.2'.to_r()        #=&gt; (-46/5)
 * '-9.2e2'.to_r()      #=&gt; (-920/1)
 * '1_234_567'.to_r()   #=&gt; (1234567/1)
 * '21 june 09'.to_r()  #=&gt; (21/1)
 * '21/06/09'.to_r()    #=&gt; (7/2)
 * 'bwv 1079'.to_r()    #=&gt; (0/1)
 **/
String.prototype.to_r = function(){
var str1 	//String auxiliar
var str2 	//String auxiliar
var op1 = &quot;0/1&quot; //operando one rational number
var op2 = 1	//operando two rational number
var pos 
var mcd
var dec

str1 = this.strip() //Returns a copy of str with leading and trailing whitespace removed
if( str1.search(/^[\d\+.-]/g) == -1 ) //Comprueba si el primer caracter es una letra o un caracter no valido)
   return op1
str2 = str1 = str1.replace(/[_]/g,&quot;&quot;)  //Replace underscore
pos = str1.search(/\//g) //Find the &quot;/&quot; character
if( pos &gt; 0) {
   str1 = str1.substring(0,pos)
   str2 = str2.substring(pos+1)
}
else
   str2 = null

if( isNaN( (op1 = parseFloat(str1)) ) )//Checks the string is a number 
   return op1
   //Comprueba si la primera cadena tiene caracteres no validos y la segunda cadena se puede pasar a numero
if( isNaN(str1) || isNaN( op2 = parseInt(str2) ) )
   op2 = 1 
	   
   //Dejo el primer numero sin decimales pasando los decimales que tuviese a la izquierdaReturns a copy of str with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase. Note: case conversion is effective only in ASCII region. 
dec = decimal(op1)
op1 = op1 * Math.pow(10,dec)
if( op2 == 1)//Si solo tenemos el operando 1
   op2 = Math.pow(10,dec)
else 
   op2 = op2 * Math.pow(10,dec)
//Calculo el maximo comun divisor de los 2 operandos
mcd = intMcd(op1,op2)
if (mcd == null)
   mcd = 1
return op1/mcd + &quot;/&quot; + op2/mcd
}


<span id='global-property-'>/***************************************************************/
</span>/* La parte de arriba es para los metodos (prototype) **********
/* La parte de abajo esta reservada para añadir funciones ******/


<span id='global-property-'>/** Esta funcion devuelve la cantidad de decimales que tiene un numero 
</span> * 
 * @memberOf *****
 * @ methof  decimal
 * @ param ( number | string )   
 * @ return (integer)  number of decimal.
 *	If the arguments is invalid return 0
 **/

function decimal() {
if(isNaN(arguments[0]))
   return -1

var num = new Number(arguments[0])
if( num &lt; Number.MIN_VALUE || num &gt; Number.MAX_VALUE)
   return 0

var ary = num.toString(10)
var trash = ary
var decUno = 0
var decDos = 0
if ( ary.search(&quot;e&quot;) &gt; 0)    {
   decUno = ary.substring(ary.search(&quot;e&quot;)+1)
   trash = ary.substring(0, ary.search(&quot;e&quot;))
}
if ( ary.search(&quot;[.]&quot;) &gt; 0){
   decDos = trash.substring(trash.search(&quot;[.]&quot;)+1)
   decDos = decDos.length
}
return parseInt(decUno)&gt;=decDos? 0 : (decUno - decDos) * -1
}

<span id='global-method-intMcd'>/** Esta funcion nos devuelve el Maximo Comun Divisor de 2 numeros
</span> * 
 * @ memberOf ******
 * @ method   intMdc
 * @ param    ( interger, integer )  
 *
 * @ return   (integer) Return the maximo comun divisor of 2 integers
 *                      If the arguments are invalids, return  null
 **/
 	
function intMcd() {

if(arguments.length != 2 || isNaN(arguments[0]) || isNaN(arguments[1]) )
   return null

var op1 = parseInt(arguments[0])
var op2 = parseInt(arguments[1])

if(arguments[0] == 0 || arguments[1] == 0)
   return null
if (arguments[0] &lt; 0)
   op1 *= -1
if (arguments[1] &lt; 0)
   op2 *= -1

while ( op1 != op2 || op1 &lt; 0 || op2&lt; 0 ){
   if(op1 &gt; op2)
      op1 = op1-op2
   else
      op2 = op2-op1
}
if( op1 == op2)
   return op1
return null 
}


<span id='global-method-bytesize'>/**
</span> * Returns the length of string in bytes.
 * 
 * @memberOf    {String}
 * @method      bytesize
 * @param       ()   
 * @return      the length of string in bytes.
 * 
 **/

String.prototype.bytesize = function(){
    return this.length
}


</pre>
</body>
</html>
